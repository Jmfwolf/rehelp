#!/bin/bash
##
## Look up how to do pull requests with git cli
## Create a way to do naming systems for PRs
## Create and installation script that looks for dependencies
##
## config_path is the target document to be changed
## changes are defined by the yamls provided
#
#
#
#
if [[ $(id -u) -eq 0 ]]; then
    echo "Do not run as root, that is dangerous." >&2
    exit 4
fi
export TRFILE="default.yml"
export REPO=""
export PATHS=()

__HELP="
rehelp is the release helper you didn't ask for. Automating changes to files through definitions is not limited to pull requests.
rehelp is intended to be flexible enough to allow automating software development. It allows for the automation of file changes and automation of pull requests on those repositories
Usage rehelp [ clone | release | release --all | transform | use <VAR_NAME> <NEW_VALUE> | get <VAR_NAME> ]
    Commands
        - use               Alters inplace the contents of yaml files in transforms directory
        - get               Prints to the command line the value of the variable
        - transform         Creates a branch and performs the indicated operations on the files in the specified repo
        - release           This create pull requests for the repo specified
        - help, -h          Display this message

    Variables in default.yml
        - service: string       defined in definitions.yml
        - environment: string   defined in definitions.yml
        - repo_url: string      url for github.com repo that a git clone can be performed
        - repo_path: string     full path to the folder that changes need to be made in
        - paths: array          defined in default.yml or template as the relative location in the repo of files to be edited
        - transform: string     the instruction(s) for how the files will be modified
        - replace: string       if the transform includes replacing text those can be stored and referenced
"

transform() {
    ./preflight.sh "t"
    local ENVIRONMENT=$(get_var "environment")
    local TRANSFORM=$(get_var "transform")
    (./preflight.sh "t"  "$TRANSFORM") &
    (./preflight.sh "e"  "$ENVIRONMENT") &
    git checkout $ENVIRONMENT
    git checkout -b 
    (cd .clones && echo $TRANSFORM && parallel ::: $TRANSFORM ::: ${PATHS[@]})
}

clone_repo(){
    local URL=$(yq '.repo_url' transforms/$TRFILE)
        ./preflight.sh "c" "$URL"
    (cd .clones && git clone $URL)
    REPO="$(basename $URL)"
    exit 0
}

use_VAR(){
    local VAR_NAME=$(echo -e ${1,,} | tr -d '[:space:]')
    local VAR_VALUE=$(echo -e ${2,,} | tr -d '[:space:]')
    echo "$VAR_NAME and $VAR_VALUE"
    local TUU=$(echo "$VAR_NAME" | yq '.strenv($1) | key' transforms/$TRFILE)
    echo $TUU
    if [[ -z $(yq '.$VAR_NAME | key' transforms/$TRFILE) ]]; then
        echo "$VAR was not found in $TRFILE, would you like to write and set it? y/n"
        read -n 2 ANS
        if [[ ! "${ANS,,}" == "y" ]]; then
            echo "$VAR_NAME not set exit"
            exit 1
        fi
    fi
    yq -i '.$VAR_NAME = $VAR_VALUE' transforms/$TRFILE
    echo "$VAR_NAME has been set to $VAR_VALUE"
    exit 0
}
get_VAR(){
    #echo $TRFILE
    local VAR="${1,,}"
    local VAL
    echo "$(yq '.$VAR as $VAL | $VAL' transforms/$TRFILE)"
    #local VAL=$(yq '.$VAR' transforms/$TRFILE || echo "ERROR: $VAR is var $VAL is val")
    #echo "$VAR: $VAL"
    exit 0
}

case $(echo "${1,,}" | tr -d '[:space:]') in
    use)        use_VAR $2 $3    ;;
    get)        get_VAR $2       ;;
    clone)      clone_repo       ;;
    transform)  transform        ;;
    help)       echo "$__HELP"   ;;
    --help)     echo "$__HELP"   ;;
    -h)         echo "$__HELP"   ;;  
    *)      echo -e "\n$1 is not a recognized command try \"rehelp -h\"" >&2
esac

